# -*- coding: utf-8 -*-
"""PHYS512HW#1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ll3RyXlZyJ0sfEiVOFtuRE2RxUSGbPYL

PHYS 512 HW#1
"""

#Import all necessary libraries
import numpy as np
import matplotlib.pyplot as plt
from scipy import integrate
import pandas as pd
import io
from google.colab import files

"""Problem 2)"""

Diode_upload = files.upload()

Diode_data = pd.read_csv(io.StringIO(Diode_upload['lakeshore.txt'].decode('utf-8')), header=None, sep='\t+', names=["Temperature", "Voltage", "Unkown"])

Diode=Diode_data.to_numpy()

plt.plot(Diode[:,0], Diode[:,1])

#setting the variables
volt=Diode[:,1]
temp=Diode[:,0]

#the code is linear spline code that connect the points with lines for interpolation
#the code take the voltages and tempretures as an inputs to construct an interpolation
#after feeding the function with a desired voltage value within the range of the voltages
#The code will interpolate an approximate tempreture 

def linear_interp(volt, temp, x):
  ind=np.max(np.where(volt>=x)[0])
  if x==volt[0]: #this to deal with the first entry since we need previous point to construct the interpolation
  #the code return the tempreture as it is for the first voltage entry
    return temp[0]
  else:
    x_use=volt[ind-1:ind+1]
    y_use=temp[ind-1:ind+1]
    dx=x_use[1]-x_use[0] #the change between the nearest two point from dataset
    t=(x-x_use[0])/dx 
    return (1-t)*y_use[0]+t*y_use[1]

temp_interp=np.zeros(len(test))
for i in range(len(volt)):
  temp_interp[i]=linear_interp(volt, temp, volt[i])

#for errors we will fit every other point and find the max error
error=np.zeros(int(len(volt)/2))
for i in range(len(error)-2):
  error[i]=linear_interp(volt[0:-1:2], temp[0:-1:2], volt[i+(i-1)+4])# I had to start with the second point since my code can not handle the first point

error_test=error[:-1]-temp[1:-2:2]
error_test=error_test[:-1]
maxError = np.amax(error_test)
maxError

plt.plot(error_test)#plot of the error at every other point. 
#As we can see as the tempreture increase the error increase since this is linear interpolation
#code that I have written take the nearest tempreture to the given voltage point
#the maximum error is about 20 degrees

plt.plot(temp,volt)
plt.plot(temp_interp,volt)#when using the full point we can see that both interpolated and true values overlap
plt.plot(error[:-2],volt[1:-4:2])# I had to subtract the edges for beyound the limit error
#the blue and orange lines are the interpolation of the full dataset
#while the green is the interpolation of everyother point which has some error

"""Problem 3)"""

#set the function for testing

#cosine function
x_c=np.linspace(-np.pi/2,np.pi/2,6)
y_c=np.cos(x_c)


#lorentzian function
x_l=np.linspace(-1,1,6)
y_l=1/(1 + x_l**2)

#copied from lecture notes with modification

#cubic spline interpoation

def cubic_interp(xi,yi):
  x=np.linspace(xi[1],xi[-2],len(xi))
  y_true=yi
  y_interp=np.zeros(len(x))
  for i in range(len(x)):    
      ind=np.max(np.where(x[i]>=xi)[0])
      x_use=xi[ind-1:ind+3]
      y_use=yi[ind-1:ind+3]
      pars=np.polyfit(x_use,y_use,3)
      pred=np.polyval(pars,x[i])
      y_interp[i]=pred

  plt.plot(x,y_interp)
  print('my rms error is ',np.std(y_interp-y_true))

#polynomial interpolatio

def poly_interp(x,y,n,m):
  xi=np.linspace(x[1],x[-2],len(x))
  pp=np.polyfit(x,y,n+m) #use same number of terms
  yy_poly=np.polyval(pp,xi)
  plt.plot(xi,yy_poly)
  print('polynomial rms error is ',np.std(yy_poly-y))


#rational function interplation

def rat_eval(p,q,x):
    top=0
    for i in range(len(p)):
        top=top+p[i]*x**i
    bot=1
    for i in range(len(q)):
        bot=bot+q[i]*x**(i+1)
    return top/bot

def rat_fit(x,y,n,m):
    assert(len(x)==n+m-1)
    assert(len(y)==len(x))
    mat=np.zeros([n+m-1,n+m-1])
    for i in range(n):
        mat[:,i]=x**i
    for i in range(1,m):
        mat[:,i-1+n]=-y*x**i
    pars=np.dot(np.linalg.pinv(mat),y)
    p=pars[:n]
    q=pars[n:]
    return p,q

def rat_interp(x,y,n,m):
  nn=n
  mm=m
  p,q=rat_fit(x,y,nn,mm)
  xx=np.linspace(x[1],x[-2],len(x))
  y_true=y
  pred=rat_eval(p,q,xx)
  #plt.clf();plt.plot(x,y,'*')
  #plt.plot(xx,y_true)
  plt.plot(xx,pred)
  fitp=np.polyfit(x,y,nn+mm-1)
  pred_poly=np.polyval(fitp,xx)
  print('rational function rms error is ',np.std(pred-y))

cubic_interp(x_c,y_c)
poly_interp(x_c,y_c,3,4)
rat_interp(x_c,y_c,3,4)

cubic_interp(x_l,y_l)
poly_interp(x_l,y_l,3,4)
rat_interp(x_l,y_l,3,4)

print(np.finfo(float).eps)

"""Problem 4)"""

#simple integrator from classnotes

def simple_integrate(fun,a,b,tol):
    x=np.linspace(a,b,5)
    dx=(b-a)/4.0
    #np.median(np.diff(x))
    y=fun(x,z,r)
    print('z=',z)
    neval=len(x) #let's keep track of function evaluations
    f1=(y[0]+4*y[2]+y[4])/6.0*(b-a)
    f2=(y[0]+4*y[1]+2*y[2]+4*y[3]+y[4])/12.0*(b-a)
    myerr=np.abs(f2-f1)
    print([a,b,f1,f2])
    if (myerr<tol):
        #return (f2)/1.0,myerr,neval
        return (16.0*f2-f1)/15.0,myerr,neval
    else:
        mid=0.5*(b+a)
        f_left,err_left,neval_left=simple_integrate(fun,a,mid,tol/2.0)
        f_right,err_right,neval_right=simple_integrate(fun,mid,b,tol/2.0)
        neval=neval+neval_left+neval_right
        f=f_left+f_right
        err=err_left+err_right
        return f,err,neval


#f,err,neval=simple_integrate(np.exp,-1,1,1e-3);pred=np.exp(1)-np.exp(-1)
#f,err,neval=simple_integrate(fun,-1,1,1e-4);pred=np.arctan(1)-np.arctan(-1)
#a=-5;b=5;f,err,neval=simple_integrate(fun2,a,b,1e-4);pred=(b-a)+np.sqrt(2*np.pi)*sig
#print('f,err,neval are ' + repr([f,err,neval])+' with err ' + repr(np.abs(f-pred)))

#setting the integral from Griffiths 2.7 solution
#the function is some constant of q, sigma and epsilon note  which we can ignore for simplisity 


def E_fun(u,z,r): 
    return (z-r*u)/((r**2)+(z**2)-(2*r*z*u))**(3/2) # I got to this final equation by looking at the griffith 2.7 solution

#testing the simple integration from lecturenote


simp_integ=[]

for z in range(300):
  simp_integ.append(simple_integrate(E_fun,-1,1,0.01))

#simple_arrinteg=np.asarray(simp_integ)[:,0]

#testing the integrate.quad for electric field

quad_integ=[]

for z in range(300):
  quad_integ.append(integrate.quad(E_fun, -1, 1,args=(z/100,1)))

arrinteg=np.asarray(quad_integ)[:,0]

plt.plot(arrinteg) 
#we can see at the plot at z=100 which is equavilant to z = radius R, the E field is maximum 
#and for z<R it is zero and at z>R it is decreasing by the form 1/z^2

